package main

/*
一个不寻常的但需要注意的细节是：来自不同库包的两个非导出方法（或者字段）将总是被认为是两个不同的标识符，
即使它们的名字完全一致。 因此，当它们的属主类型被同时内嵌在同一个结构体类型中的时候，它们绝对不会相互碰
撞或者遮挡。 举个例子，下面这个含有两个库包的Go程序编译和运行都没问题。 但是，如果将其中所有出现的m()
改为M()，则此程序将编译不过。 原因是A.M和B.M碰撞了，导致c.M为一个非法的选择器。
*/
import (
	bar "embed/far"
	"embed/foo"
	"fmt"
)

type B struct {
	n bool
}

// 因为这个 m() 为非导出的
// C 中的 foo.A 中的 m 也是非导出的, 在这个 main 是没有权限访问 foo.A 的 m()
// 所以在 main 中 c.m() 调用时，编译器是知道这个方法是唯一的
// 但是如果把这两个 m() 都改成导出的 M()，则这里就编译不通过了，因为编译器跟本不知道调用的是哪个

// 这里有个问题，如果把 foo.A 中的 m() 改为 M() 导出型，如何调用这个 M() 呢？
// 错误：c.foo.A.N()
// 正确：c.A.N()

func (b B) m() {
	fmt.Println("B", b.n)
}

type C struct {
	B
	// 如何区分 foo.A 和 bar.A
	A foo.A
	D bar.A
}

func main() {
	var c C
	// B
	c.m()
	//c.
	c.A.M()
	c.D.M()
}
